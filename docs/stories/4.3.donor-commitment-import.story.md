# Story 4.3: Donor Commitment Import

## Status
**Approved**

## Story
**As a** responder,  
**I want** to import donor commitment details,  
**so that** response documentation is accurate and efficient.

## Acceptance Criteria

1. Import interface showing available commitments
2. Select items from donor commitments
3. Partial commitment usage tracking
4. Auto-populate response fields
5. Maintain donor attribution
6. Mark imported items as delivered
7. Backend API for commitment retrieval
8. Integration tests for import workflow

## Tasks / Subtasks

- [ ] **Task 0: Create Direct Incident-Entity Relationship** (AC: 1, 2) ✅
  - [ ] Add IncidentEntity junction table to Prisma schema with proper constraints
  - [ ] Create migration script to populate from existing PreliminaryAssessment data
  - [ ] Add indexes for performance (incidentId, entityId, severity)
  - [ ] Update Entity and Incident models with new relations
  - [ ] Create seed data migration strategy for existing incidents
  - [ ] Add validation logic to ensure data integrity
  - [ ] Document new direct relationship query patterns

- [ ] **Task 1: Database Schema Extension - Donor Commitment Model** (AC: 2, 3, 5) ✅
  - [ ] Add DonorCommitment model to Prisma schema
  - [ ] Define commitment item structure with quantity tracking
  - [ ] Add partial usage tracking fields (deliveredQuantity, verifiedDeliveredQuantity)
  - [ ] Create database migration for new tables
  - [ ] Add indexes for performance (donorId, entityId, incidentId)
  - [ ] Seed sample commitment data for development

- [ ] **Task 2: Backend API - Commitment Management** (AC: 1, 7) ✅
  - [ ] Create `GET /api/v1/donors/{id}/commitments` endpoint
  - [ ] Create `GET /api/v1/commitments/available` endpoint for responders
  - [ ] Implement entity and incident-based filtering
  - [ ] Add commitment item selection and partial usage logic
  - [ ] Create commitment status management (PLANNED, PARTIAL, COMPLETE)
  - [ ] Add audit logging for commitment operations

- [ ] **Task 3: Backend API - Commitment Import Integration** (AC: 3, 4, 5, 6) ✅
  - [ ] Create `POST /api/v1/responses/from-commitment` endpoint
  - [ ] Implement auto-population of response fields from commitment
  - [ ] Add partial commitment quantity deduction logic
  - [ ] Maintain donor attribution in response records
  - [ ] Mark commitment items as delivered upon import
  - [ ] Add validation for commitment availability and quantities

- [ ] **Task 4: Frontend - Commitment Import Interface** (AC: 1, 2) ✅
  - [ ] Create DonorCommitmentImportForm component
  - [ ] Build commitment selection interface with search/filter
  - [ ] Implement item-level selection within commitments
  - [ ] Add quantity adjustment for partial usage
  - [ ] Create commitment preview and confirmation dialog
  - [ ] Integrate with existing response planning workflow

- [ ] **Task 5: Frontend - Response Integration** (AC: 4, 5, 6) ✅
  - [ ] Modify ResponsePlanningForm to support commitment import
  - [ ] Add "Import from Commitment" button and workflow
  - [ ] Auto-populate response fields from selected commitment items
  - [ ] Display donor attribution clearly in response form
  - [ ] Handle partial quantity calculations and validation
  - [ ] Create response delivery confirmation with commitment linkage

- [ ] **Task 6: Offline Support for Commitment Import** (AC: 1, 2, 4, 5) ✅
  - [ ] Extend offline storage for commitment data
  - [ ] Create offline commitment import functionality
  - [ ] Add sync queue for commitment-based responses
  - [ ] Implement conflict resolution for commitment usage
  - [ ] Add offline indicators for commitment operations
  - [ ] Test offline-to-online commitment sync scenarios

- [ ] **Task 7: Authorization & Entity Assignment Integration** (AC: 1, 2) ✅
  - [ ] Integrate with EntityAssignmentService for commitment access
  - [ ] Ensure responders only see commitments for assigned entities
  - [ ] Add role-based access control (RESPONDER role required)
  - [ ] Implement donor permission checks for commitment viewing
  - [ ] Add audit logging for commitment access and usage

- [ ] **Task 8: Comprehensive Testing Suite** (All ACs) ✅
  - [ ] Unit tests for commitment calculation logic
  - [ ] Integration tests for commitment API endpoints
  - [ ] Component tests for import interface
  - [ ] E2E tests for complete commitment import workflow
  - [ ] Offline commitment import testing
  - [ ] Performance tests for large commitment datasets
  - [ ] Security testing for commitment access controls

## Dev Notes

### **Critical Schema Requirement: New Models**

**1. IncidentEntity Junction Table (NEW)**
The current schema lacks a direct incident-entity relationship. This must be added first:

```prisma
model IncidentEntity {
  id         String    @id @default(uuid())
  incidentId String
  entityId   String
  affectedAt DateTime  @default(now())
  severity   Priority  @default(MEDIUM)
  
  incident   Incident  @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  entity     Entity    @relation(fields: [entityId], references: [id], onDelete: Cascade)
  
  @@unique([incidentId, entityId])
  @@index([incidentId])
  @@index([entityId])
  @@map("incident_entities")
}
```

**2. DonorCommitment Model**
The core model for donor commitment tracking:

```prisma
model DonorCommitment {
  id                      String             @id @default(uuid())
  donorId                 String
  entityId                String
  incidentId              String
  status                  CommitmentStatus   @default(PLANNED)
  items                   Json               // [{ name: string, unit: string, quantity: number }]
  totalCommittedQuantity  Int                @default(0)
  deliveredQuantity       Int                @default(0)
  verifiedDeliveredQuantity Int              @default(0)
  commitmentDate          DateTime           @default(now())
  lastUpdated             DateTime           @updatedAt
  notes                   String?
  
  donor                   Donor              @relation(fields: [donorId], references: [id])
  entity                  Entity             @relation(fields: [entityId], references: [id])
  incident                Incident           @relation(fields: [incidentId], references: [id])
  responses               RapidResponse[]    @relation("CommitmentResponses")
  
  @@index([donorId, entityId])
  @@index([donorId, incidentId])
  @@index([status])
  @@index([entityId, incidentId])
  @@map("donor_commitments")
}

enum CommitmentStatus {
  PLANNED
  PARTIAL
  COMPLETE
  CANCELLED
}
```

**Schema Updates Needed**:

**1. Add IncidentEntity junction table with proper constraints**
**2. Add DonorCommitment model to schema**

**3. Update Existing Models**:

```prisma
model Donor {
  id           String          @id @default(uuid())
  name         String
  type         DonorType       @default(ORGANIZATION)
  contactEmail String?
  contactPhone String?
  organization String?
  isActive     Boolean         @default(true)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  responses    RapidResponse[] @relation("DonorResponses")
  commitments  DonorCommitment[] // NEW: Add this relation
  
  @@map("donors")
}

model Entity {
  id                 String             @id @default(uuid())
  name               String
  type               EntityType
  location           String?
  coordinates        Json?
  metadata           Json?
  isActive           Boolean            @default(true)
  autoApproveEnabled Boolean            @default(false)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  assignments        EntityAssignment[]
  rapidAssessments   RapidAssessment[]
  responses          RapidResponse[]    @relation("EntityResponses")
  incidents          IncidentEntity[]    // NEW: Direct incident relationship
  commitments        DonorCommitment[]   // NEW: Commitment relationship
  
  @@unique([name, type])
  @@map("entities")
}

model Incident {
  id                     String                  @id @default(uuid())
  type                   String
  subType                String?
  severity               Priority                @default(MEDIUM)
  status                 IncidentStatus          @default(ACTIVE)
  description            String
  location               String
  coordinates            Json?
  createdBy              String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  preliminaryAssessments PreliminaryAssessment[]
  entities               IncidentEntity[]         // NEW: Direct entity relationship
  commitments            DonorCommitment[]        // NEW: Commitment relationship
  
  @@map("incidents")
}

model RapidResponse {
  id                 String             @id @default(uuid())
  responderId        String
  entityId           String
  assessmentId       String
  type               ResponseType
  priority           Priority           @default(MEDIUM)
  status             ResponseStatus     @default(PLANNED)
  description        String?
  resources          Json?
  timeline           Json?
  versionNumber      Int                @default(1)
  isOfflineCreated   Boolean            @default(false)
  verificationStatus VerificationStatus @default(DRAFT)
  verifiedAt         DateTime?
  verifiedBy         String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  donorId            String?
  commitmentId       String?            // NEW: Track commitment import source
  items              Json
  offlineId          String?            @unique
  plannedDate        DateTime           @default(now())
  rejectionFeedback  String?
  rejectionReason    String?
  responseDate       DateTime?
  syncStatus         SyncStatus         @default(LOCAL)
  mediaAttachments   MediaAttachment[]
  assessment         RapidAssessment    @relation("AssessmentResponses", fields: [assessmentId], references: [id])
  donor              Donor?             @relation("DonorResponses", fields: [donorId], references: [id])
  commitment         DonorCommitment?   @relation("CommitmentResponses", fields: [commitmentId], references: [id]) // NEW
  entity             Entity             @relation("EntityResponses", fields: [entityId], references: [id])
  responder          User               @relation("UserResponses", fields: [responderId], references: [id])
  conflicts          SyncConflict[]     @relation("ResponseConflicts")
  
  @@index([commitmentId]) // NEW: Index for commitment-based queries
  @@map("rapid_responses")
}
```

### Database Integration Patterns
**Source**: Architecture docs 9.4 - Entity Assignment Service  
Use existing `EntityAssignmentService` to validate responder access to entities when filtering commitments.

### Direct Incident-Entity Query Patterns
**NEW Direct Relationship**: Simple, reliable connection between incidents and entities:

```typescript
// Get entities for an incident (NEW - Simple & Reliable)
const incidentEntities = await prisma.incidentEntity.findMany({
  where: { incidentId: "incident-123" },
  include: {
    entity: true,
    incident: true
  }
});

// Get available commitments for incident responders (NEW - Efficient)
const availableCommitments = await prisma.donorCommitment.findMany({
  where: {
    status: 'PLANNED',
    incidentId: "incident-123",
    entityId: { in: assignedEntityIds }
  },
  include: {
    donor: true,
    entity: true,
    incident: true
  }
});

// Create response from commitment with full relationship tracking (NEW)
const responseFromCommitment = await prisma.rapidResponse.create({
  data: {
    responderId: "responder-123",
    entityId: commitment.entityId,
    assessmentId: "assessment-456", // Linked assessment
    type: "FOOD", // From commitment items
    status: "DELIVERED",
    items: commitment.items, // Auto-populate from commitment
    donorId: commitment.donorId, // Maintain donor attribution
    commitmentId: commitment.id, // Track source commitment
    responseDate: new Date()
  },
  include: {
    commitment: true, // Show commitment source
    donor: true,      // Show donor attribution
    entity: true      // Show affected entity
  }
});

// Check if an entity is affected by an incident (NEW - Fast lookup)
const isAffected = await prisma.incidentEntity.findUnique({
  where: {
    incidentId_entityId: {
      incidentId: "incident-123",
      entityId: "entity-456"
    }
  }
});
```

**Migration Strategy**: Populate IncidentEntity from existing PreliminaryAssessment data:
```typescript
// One-time migration script
const preliminaryAssessments = await prisma.preliminaryAssessment.findMany({
  where: { incidentId: { not: null } }
});

for (const assessment of preliminaryAssessments) {
  // Match assessment location to entities (by LGA/Ward matching)
  const matchingEntities = await prisma.entity.findMany({
    where: {
      // Logic to match assessment.reportingWard/reportingLGA to entity location
    }
  });

  for (const entity of matchingEntities) {
    await prisma.incidentEntity.create({
      data: {
        incidentId: assessment.incidentId,
        entityId: entity.id,
        severity: 'MEDIUM' // Default or assessment-based
      }
    });
  }
}
```

### API Architecture
**Source**: Architecture docs 8.9 - Donor Management Endpoints  
Follow existing donor API patterns:
- RESTful endpoints: `/api/v1/donors/{id}/commitments`
- Response format: Use existing `ApiResponse<T>` pattern
- Authentication: Use existing `withAuth` middleware pattern
- Role checks: Manual role validation (COORDINATOR, RESPONDER, DONOR)

### Response System Integration
**Source**: Story 4.2 Delivery Documentation (completed)  
Leverage existing response infrastructure:
- Use existing `RapidResponse.items` JSON structure for commitment items
- Follow existing `ResponseStatus.PLANNED → DELIVERED` pattern
- Integrate with existing verification queue system
- Use existing `MediaAttachment` system for delivery proof

### Frontend Component Architecture
**Source**: Architecture docs 4.1 - Directory Organization  
Component locations based on project structure:
- `src/components/forms/response/DonorCommitmentImportForm.tsx`
- `src/components/forms/response/CommitmentSelector.tsx`
- `src/components/forms/response/CommitmentItemSelector.tsx`
- Extend existing `src/components/forms/response/ResponsePlanningForm.tsx`

### Testing Strategy
**Source**: `docs/prd/testing-strategy.md`  
Required test coverage:
- **Unit Tests**: `tests/unit/commitment-import.test.ts`
- **Integration Tests**: `tests/integration/commitment-api.test.ts`
- **Component Tests**: `tests/components/DonorCommitmentImportForm.test.tsx`
- **E2E Tests**: `tests/e2e/commitment-import-workflow.spec.ts`

### Security & Authorization
**Source**: Architecture docs 9.3 - Authorization Middleware  
Use existing auth patterns:
- `withAuth` wrapper for API routes
- Manual role checks: `if (!roles.includes('RESPONDER'))`
- Entity assignment validation via `EntityAssignmentService`

### Performance Considerations
**Expected Scale**: Based on crisis response patterns, anticipate:
- 100-1000 commitments per incident
- 10-100 items per commitment
- Concurrent access by 50+ responders during peak response

**Optimization Requirements**:
- Database indexing: Use provided indexes for donorId, entityId, incidentId, status
- API pagination: Implement cursor-based pagination for large commitment datasets
- Frontend virtualization: Use react-window for commitment selection lists with 100+ items
- Offline sync: Batch commitment operations to reduce sync frequency
- Query optimization: Use Prisma's `select` to limit returned fields where possible

**Performance Benchmarks**:
- Commitment API response: <200ms for typical queries
- Commitment selection UI: <100ms render time for 100+ items
- Offline-to-online sync: <5 seconds for 50 commitment-based responses

### File Structure for New Features
```
src/
├── app/api/v1/commitments/
│   ├── [donorId]/route.ts              # Get donor commitments
│   └── available/route.ts              # Get available commitments for responders
├── app/api/v1/responses/
│   └── from-commitment/route.ts        # Create response from commitment
├── components/forms/response/
│   ├── DonorCommitmentImportForm.tsx   # Main import form
│   ├── CommitmentSelector.tsx          # Commitment selection
│   └── CommitmentItemSelector.tsx      # Item selection within commitments
└── lib/services/
    └── commitment.service.ts           # Commitment business logic
```

### Integration Points with Existing System
1. **Response Planning**: Extend existing ResponsePlanningForm with import capability
2. **Entity Assignment**: Use existing assignment system for commitment filtering  
3. **Incident-Entity Management**: NEW - Use direct IncidentEntity relationship for reliable incident-wide operations
4. **Verification Queue**: Commitment-based responses use existing verification workflow
5. **Audit Logging**: Use existing AuditLog model for commitment operations
6. **Media Attachments**: Use existing MediaAttachment system for delivery proof

### Architectural Benefits of Direct Relationship
- **Data Integrity**: Foreign key constraints ensure valid incident-entity pairs
- **Query Performance**: Direct lookups instead of complex assessment joins
- **Complete Coverage**: Entities are tracked even before assessments are created
- **Business Clarity**: Clear declaration of which entities are officially affected
- **Scalability**: Efficient filtering for large incidents with many entities

## Testing

**Note**: Testing strategy consolidated from Dev Notes to eliminate redundancy

### Testing Strategy Alignment
Following `docs/prd/testing-strategy.md`:

**Unit Tests (Vitest):**
- Commitment calculation and partial usage logic
- API endpoint validation and error handling
- Component form validation and state management
- Database query optimization and indexing
- **Performance Tests**: Query optimization with large commitment datasets

**Integration Tests (Real Database):**
- Commitment API endpoints with authentication
- Database transactions and constraint validation
- Entity assignment filtering for commitments
- Commitment usage deduction and status updates
- **Scale Tests**: Performance with 1000+ commitments

**Component Tests (Testing Library):**
- DonorCommitmentImportForm workflow
- Commitment selection and item quantity adjustment
- Response field auto-population from commitments
- Error handling and validation feedback
- **Performance Tests**: UI responsiveness with large commitment lists

**E2E Tests (Playwright):**
- Complete commitment import workflow
- Partial commitment usage scenarios
- Offline commitment import and sync
- Role-based access control validation
- **Load Tests**: Multiple concurrent responders importing commitments

### Test File Locations
- `tests/unit/commitment-import.test.ts`
- `tests/integration/commitment-api.test.ts`
- `tests/components/DonorCommitmentImportForm.test.tsx`
- `tests/e2e/commitment-import-workflow.spec.ts`

### Specific Test Scenarios Required
1. **Commitment Selection**: Filter by entity, incident, donor
2. **Partial Usage**: Import partial quantities with correct deduction
3. **Auto-population**: Response fields correctly populated from commitment
4. **Donor Attribution**: Donor information maintained in responses
5. **Offline Support**: Commitment import works offline with proper sync
6. **Access Control**: Responders only see commitments for assigned entities
7. **Status Management**: Commitment status updates (PLANNED → PARTIAL → COMPLETE)
8. **Performance**: Commitment selection with 1000+ items responds <200ms
9. **Concurrent Access**: Multiple responders importing simultaneously without conflicts

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-06 | 1.0 | Initial story draft created from epic requirements | Scrum Master Bob |

## Dev Agent Record

### Agent Model Used
<!-- To be populated by development agent -->

### Debug Log References
<!-- To be populated by development agent -->

### Completion Notes List
<!-- To be populated by development agent -->

### File List
<!-- To be populated by development agent -->

## QA Results
<!-- To be populated by QA agent during review -->